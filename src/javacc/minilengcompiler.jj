//*****************************************************************
// File:   MiniLengCompiler.jj
// Author: Andrés Gavín Murillo 716358
// Date:   5/6/2019
// Coms:   Procesadores de lenguajes - Compilador de MiniLengCompiler V4.0
//         JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
//*****************************************************************
options{    static = true;
    ignore_case = true;}PARSER_BEGIN(MiniLengCompiler)

package javacc;

import java.io.FileInputStream;
import lib.lexico.TablaVeces;
import lib.semantico.TablaSimbolos;
import lib.semantico.RegistroExpr;
import lib.semantico.RegistroExpr.TipoOperador;
import lib.semantico.Simbolo;
import lib.semantico.Simbolo.Clase_parametro;
import lib.semantico.Simbolo.Tipo_variable;
import lib.semantico.ErrorSemantico;
import lib.semantico.SimboloNoEncontradoException;
import lib.semantico.SimboloNoAsignableException;
import lib.semantico.SimboloYaExistenteException;
import lib.semantico.SimboloNoConcuerdaException;
import lib.semantico.SimboloNoAccionException;
import lib.semantico.ExcesoParametrosException;
import lib.semantico.DivisionPorCeroException;
import lib.semantico.NumeroFueraRangoException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.ListIterator;
import lib.genCodigo.GeneracionCodigo;
import lib.genCodigo.FicheroFormatoException;
import lib.genCodigo.FicheroEscribirException;

public class MiniLengCompiler {
    static boolean correcto = true;
    static boolean panic_mode = false;
    
    static TablaSimbolos tabla_simbolos = new TablaSimbolos();
    static Long dir = new Long(3);
    static int nivel = 0;
    static boolean tabla_simbolos_print = false;

    static GeneracionCodigo genCod;
    
    public static void main(String args []) throws ParseException {
        System.out.println("Compilador de MiniLengCompiler V3.1 Autor: Andrés Gavín Murillo 716358. Ayuda: ./compilador -h\n");
        
        Boolean verbose = false;
        MiniLengCompiler compiler;
        TablaVeces tabla = new TablaVeces();

        // Lanzar compilador
        if (args.length == 0) { // Sin argumentos
            System.out.println("Uso: ./compilador [argumentos] [archivo]");
            return ;
        }
        else { // Opción ayuda
            if (args[0].equals("-h")) {
                System.out.println("Uso: ./compilador [argumentos] [archivo]");
                System.out.println("     [] -> opcional");
                System.out.println("Argumentos:");
                System.out.println("    -h  -> Muestra la ayuda");
                System.out.println("    -p  -> Panic mode");
                System.out.println("    -v  -> Muestra un resumen de las apariciones de los símbolos");
                System.out.println("    -s  -> Muestra la tabla de símbolos cada vez que se cierre un bloque");
                return ;
            }
            else {
                String file_name = null;
                
                for (int i=0; i<args.length; i++) {
                    if (args[i].equals("-p"))
                        panic_mode = true;
                    else if (args[i].equals("-v"))
                        verbose = true;
                    else if (args[i].equals("-s"))
                        tabla_simbolos_print = true;
                    else
                        file_name = args[i];
                }

                if (file_name != null) { 
	               try {
	                   compiler = new MiniLengCompiler(new FileInputStream(file_name));
	                   genCod = new GeneracionCodigo(file_name);
	               }
	               catch (java.io.FileNotFoundException e) {
	                   System.out.println("Fichero " + file_name + " no encontrado.");
	                   return ;
	               }
                   catch (FicheroFormatoException e) {
                       System.out.println("El fichero " + file_name + " tiene que tener formato '.ml'.");
                       return ;
                   }
                }
	            else {
	               System.out.println("Fichero no encontrado.");
                   return ;
                }
            }

            try { 
                MiniLengCompiler.programa(verbose);
                if (correcto)
                    System.out.println("Compilación correcta.");
            }
            //catch (Exception e) { System.err.println("Error no reconocido"); }
            catch (Error e) { // Error léxico
                System.out.println("ERROR LÉXICO (<" + SimpleCharStream.getBeginLine() + ", " + 
                    SimpleCharStream.getBeginColumn() + ">) : símbolo no reconocido: <" +
                    SimpleCharStream.GetImage().charAt(MiniLengCompilerTokenManager.curLexState) + ">");
                
                return ;
            }
        }
    }

    private static void panic(ParseException e, String msg, int kind) {
        Token lastRead = MiniLengCompiler.getNextToken();

        while (token.kind != kind && token.kind != EOF)
            token = MiniLengCompiler.getNextToken();

        String error_msg = "AVISO SINTÁCTICO (<" + lastRead.beginLine + ", " + 
            lastRead.beginColumn + ">) : <";
        if (kind != tFIN)
            error_msg += "Símbolo obtenido: '" + lastRead.image + "'. ";
        error_msg += msg + " (PANIC MODE)>";
        
        System.out.println(error_msg);
    }

    private static void error_sintactico(ParseException e, String msg) {
        correcto = false;
        Token lastRead = MiniLengCompiler.getNextToken();
        //Token lastRead = MiniLengCompiler.token.next;
	    System.out.println("ERROR SINTÁCTICO (<" + lastRead.beginLine + ", " + 
	        lastRead.beginColumn + ">) : <Símbolo obtenido: '" + lastRead.image +
	        "'. " + msg + ">");
    }

    private static void error_sintactico(ParseException e) {
        error_sintactico(e, "");
    }
}
PARSER_END(MiniLengCompiler)SKIP :{  " "| "\r"| "\t"| "\n"
| < ["%"] ~["%"] > : COMENTARIO
| < ["%"] ["%"] > : COMENTARIO_DOBLE}

< COMENTARIO > SKIP :
{
  "\n" : DEFAULT
}

< COMENTARIO > MORE :
{
  < ~[] >
}

< COMENTARIO_DOBLE > SKIP :
{
  "%%" : DEFAULT
}

< COMENTARIO_DOBLE > MORE :
{
  < ~[] >
}

TOKEN : /* Estructuras */
{  < tPROGRAMA : "programa" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tPROGRAMA);
    }
| < tPRINCIPIO : "principio" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tPRINCIPIO);
    }
| < tFIN : "fin" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tFIN);
    }
| < tSI : "si" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tSI);
    }
| < tENT : "ent" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tENT);
    }
| < tSI_NO : "si_no" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tSI_NO);
    }
| < tFSI : "fsi" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tFSI);
    }
| < tMQ : "mq" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tMQ);
    }
| < tFMQ : "fmq" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tFMQ);
    }
| < tACCION : "accion" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tACCION);
    }
| < tPC : ";" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tPC);
    }
| < tC : "," >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tC);
    }
}

TOKEN : /* Tipos de datos */
{
  < tVAR : "var" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tVAR);
    }
| < tENTERO : "entero" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tENTERO);
    }
| < tBOOLEANO : "booleano" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tBOOLEANO);
    }
| < tCARACTER : "caracter" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tCARACTER);
    }
| < tVAL : "val" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tVAL);
    }
| < tREF : "ref" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tREF);
    }
}

TOKEN : /* Operadores lógicos */
{
  < tAND : "and" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tAND);
    }
| < tOR : "or" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tOR);
    }
| < tNOT : "not" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tNOT);
    }
| < tMAYOR : ">" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tMAYOR);
    }
| < tMENOR : "<" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tMENOR);
    }
| < tIGUAL : "=" >
    {
      TablaVeces.incrementarValor(TablaVeces.tipo_token.tIGUAL);
    }
| < tMAI : ">=" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tMAI);
    }
| < tMEI : "<=" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tMEI);
    }
| < tNI : "<>" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tNI);
    }
| < tTRUE : "true" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tTRUE);
    }
| < tFALSE : "false" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tFALSE);
    }
}

TOKEN : /* Operaciones */
{
  < tESCRIBIR : "escribir" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tESCRIBIR);
    }
| < tLEER : "leer" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tLEER);
    }
| < tENTACAR : "entacar" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tENTACAR);
    }
| < tCARAENT : "caraent" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tCARAENT);
    }
}
TOKEN : /* Operadores aritméticos */{
  < tMOD : "mod" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tMOD);
    }
| < tDIV : "div" | "/" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tDIV);
    }
| < tOPAS : ":=" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tOPAS);
    }
| < tSUMA : "+" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tSUMA);
    }
| < tRESTA : "-" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tRESTA);
    }
| < tMULTIPLICA : "*" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tMULTIPLICA);
    }
| < tAP : "(" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tAP);
    }
| < tCP : ")" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tCP);
    }}TOKEN :{  < tCONSTENTERA : (< DIGITO >)+ >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tCONSTENTERA);
    }| < #DIGITO : [ "0"-"9" ] >
| < tCONSTCHAR : ["\""] ~["\""] ["\""] >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tCONSTCHAR);
    }
| < tCONSTCAD : ["\""] (~["\""])+ ["\""] >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tCONSTCAD);
    }
| < tIDENTIFICADOR : (< LETRA > | (< LETRA > | "_") (< LETRA > | < DIGITO > | "_")*
    (< LETRA > | < DIGITO >)) >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tIDENTIFICADOR);
    }
| < #LETRA : [ "A"-"Z" ] >}

// Análisis sintáctico

void punto_y_coma() :
{}
{
    try { 
        <tPC>
    }
    catch (ParseException e) { // Error sintáctico
        if (panic_mode)
            panic(e, "Se esperaba ';'", tPC);
        else
            error_sintactico(e, "Se esperaba ';'");
    }
}

Token identificador() :
{
    Token t = null;
}
{
    try { 
        t = <tIDENTIFICADOR>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba un identificador");
    }
    
    {
        return t;
    }
}
void programa(Boolean verbose) :
{
    Token t = null;

    // Generación de código
    genCod.inicializar();
    String etiq;
}
{
    try { 
	    <tPROGRAMA>
	    t = identificador() {
	        if (t != null) {
	            tabla_simbolos.introducir_programa(t.image, null);

	            // Generación de código
		        genCod.escribir("; Programa " + t.image);
		    }
		    etiq = genCod.nueva_etiqueta();
            genCod.instruccion("ENP " + etiq);
	    }
	    punto_y_coma()
	    declaracion_variables()
	    declaracion_acciones() {
            // Generación de código
            genCod.escribir("; Comienzo del programa " + t.image);
            genCod.escribir(etiq + ":");
        }
	    bloque_sentencias()
	    ( <EOF> )?
	        {
	            correcto = correcto && ErrorSemantico.getCorrecto();
	            
	            // Generación de código
	            if (t != null) {
	                genCod.escribir("; Fin de " + t.image);
	            }
	            genCod.instruccion("LVP");
	            
                try {
                    genCod.finalizar(correcto);
                }
                catch (FicheroEscribirException e) {
                   System.out.println("No se ha podido generar el fichero, revise los permisos.");
                   correcto = false;
                }

	            if (correcto) {
                    tabla_simbolos.eliminar_variables(nivel);
                    tabla_simbolos.eliminar_acciones(nivel);
                    //tabla_simbolos.eliminar_parametros_ocultos(nivel+1); // Si todas acciones tienen param 
                    tabla_simbolos.eliminar_programa();
                    
                    if (tabla_simbolos_print)
                        System.out.println(tabla_simbolos.toString());
                    if (verbose)
                        TablaVeces.print();
                }
	            return;
	        }
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba la declaración del programa");
    }
}

void declaracion_variables() :
{}
{
    try { 
        (
          declaracion()
          punto_y_coma()
        )*
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void declaracion() :
{
    Token t = null;
    ArrayList<Token> ids;
    Tipo_variable tipo;
}
{
    try { 
        tipo = tipo_variables()
        ids = identificadores() {
            for (int i=0; i<ids.size(); i++) {
                t = ids.get(i);
                try { 
                    tabla_simbolos.introducir_variable(t.image, tipo, nivel, dir);
                    if (tipo == Tipo_variable.ENTERO) {
                        dir += 2;
                    }
                    else {
                        dir++;
                    }
                }
			    catch (SimboloYaExistenteException e) { // Error semántico
			        ErrorSemantico.error_semantico(e, t);
			    }
            }
        }
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

Tipo_variable tipo_variables() :
{
    Tipo_variable tipo = null;
}
{
    try { 
          <tENTERO> {
              tipo = Tipo_variable.ENTERO;
          }
        | <tCARACTER> {
              tipo = Tipo_variable.CHAR;
          }
        | <tBOOLEANO> {
              tipo = Tipo_variable.BOOLEANO;
          }
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba el tipo de varibale");
    }

    {
        return tipo;
    }
}

ArrayList<Token> identificadores() :
{
    ArrayList<Token> tokens = new ArrayList<Token>();
    Token t = null;
}
{
    try { 
        t = identificador() {
            if (t != null) 
                tokens.add(t);
        }
        (
          <tC>
          t = identificador() {
              if (t != null) 
                  tokens.add(t);
          }
        )*
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }

    {
        return tokens;
    }
}

void declaracion_acciones() :
{}
{
    try { 
        (
          declaracion_accion()
        )*
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void declaracion_accion() :
{
    Token t = null;
    String etiq;
}
{
    try { 
        t = cabecera_accion() {
            etiq = genCod.nueva_etiqueta();
        }
        punto_y_coma()
        declaracion_variables()
        declaracion_acciones() {
            // Generación de código
            genCod.escribir("; Comienzo de " + t.image);
            genCod.escribir(etiq + ":");
        }
        bloque_sentencias() {
            tabla_simbolos.eliminar_variables(nivel);
            tabla_simbolos.eliminar_acciones(nivel);
            tabla_simbolos.ocultar_parametros(nivel);
            nivel--;
            
            // Generación de código
            genCod.escribir("; Fin de " + t.image);
        }
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

Token cabecera_accion() :
{
    Token t = null;
}
{
    try { 
        <tACCION>
        t = identificador() {
            if (t != null) { 
	            try { 
	                tabla_simbolos.introducir_accion(t.image, nivel, null);
	            }
			    catch (SimboloYaExistenteException e) { // Error semántico
			        ErrorSemantico.error_semantico(e, t);
			    }
	            nivel++;
	        }
        }
        parametros_formales()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba la declaración de una acción");
    }

    {
        return t;
    }
}

void ap() :
{}
{
    try { 
        <tAP>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba '('");
    }
}

void cp() :
{}
{
    try { 
        <tCP>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba ')'");
    }
}

void parametros_formales() :
{}
{
    try { 
        (
          ap()
          (
            parametros()
          )*
          cp()
        )?
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void lista_parametros() :
{}
{
    try { 
        (
          punto_y_coma()
          parametros()
        )?
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void parametros() :
{
    Token t = null;
    ArrayList<Token> ids;
    Clase_parametro clase;
    Tipo_variable tipo;
}
{
    try { 
        clase = clase_parametros()
        tipo = tipo_variables()
        ids = identificadores() {
            for (int i=0; i<ids.size(); i++) {
                t = ids.get(i);
                try { 
                    tabla_simbolos.introducir_parametro(t.image, tipo, clase, nivel, dir);
                    if (clase == Clase_parametro.VAL && tipo == Tipo_variable.ENTERO) {
                        dir += 2;
                    }
                    else {
                        dir++; // Las referencias también ocupan 1
                    }
                }
			    catch (SimboloYaExistenteException e) { // Error semántico
			        ErrorSemantico.error_semantico(e, t);
			    }
            }
        }
        lista_parametros()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

Clase_parametro clase_parametros() :
{
    Clase_parametro clase = null;
}
{
    try { 
          <tVAL> {
              clase = Clase_parametro.VAL;
          }
        | <tREF> {
              clase = Clase_parametro.REF;
          }
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba la clase de parámetro");
    }

    {
        return clase;
    }
}

void principio() :
{}
{
    try { 
        <tPRINCIPIO>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba la declaración del principio del bloque");
    }
}

void bloque_sentencias() :
{}
{
    try { 
        principio()
        lista_sentencias()
        <tFIN> {
	        if (tabla_simbolos_print)
	            System.out.print(tabla_simbolos.toString());
        }
    }
    catch (ParseException e) { // Error sintáctico
        if (panic_mode)
            panic(e, "Se esperaba la declaración del fin del bloque", tFIN);
        else
            error_sintactico(e, "Se esperaba la declaración del fin del bloque");
    }
}

void lista_sentencias() :
{}
{
    try { 
        (
          sentencia()
        )+
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void sentencia() :
{}
{
    try { 
          leer() punto_y_coma()
	    | escribir() punto_y_coma()
	    | identificacion()
	    | seleccion()
	    | mientras_que()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba una instrucción");
    }
}

void leer() :
{}
{
    try { 
        <tLEER>
        ap()
        lista_asignables()
        cp()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba una operación de lectura");
    }
}

void lista_asignables() :
{
    ArrayList<Token> ids = null;
    Token t = null;
    Simbolo s = null;
}
{
    try { 
        ids = identificadores() {
            for (int i=0; i<ids.size(); i++) {
                t = ids.get(i);
	            if (t != null) {
	                try { 
	                    s = tabla_simbolos.buscar_simbolo(t.image);
	                    // Lectura: Debe ser asignable y del tipo entero, carácter o desconocido
		                if (!(s.es_asignable() &&
		                      (s.es_entero() || s.es_caracter() || s.es_desconocido()))) {
		                    ErrorSemantico.error_semantico(new SimboloNoAsignableException(), t);
		                }
		                else {
		                    // Generación de código
		                    genCod.escribir("; Leer");
                            genCod.escribir("; Direccion de variable " + s.getNombre());
		                    genCod.instruccion("SRF 0 " + s.strDir());
		                    if (s.es_caracter()) {
		                        genCod.instruccion("RD 0");
		                    }
		                    else {
                                genCod.instruccion("RD 1");
                            }
		                }
	                }
	                catch (SimboloNoEncontradoException e) {
	                    ErrorSemantico.error_semantico(e, t);
	                    try { 
	                        s = tabla_simbolos.introducir_variable(t.image, Tipo_variable.DESCONOCIDO, nivel, dir);
	                        dir++; // Si la compilación es correcta no se utiliza
	                    }
	                    catch (SimboloYaExistenteException ignored) { } // Imposible
	                }
	            }
            }
        }
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void escribir() :
{}
{
    try { 
        <tESCRIBIR>
        ap() {
            genCod.escribir("; Escribir");
        }
        lista_escribibles()
        cp()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba una operación de escritura");
    }
}

String constcad() :
{
    Token t;
    String s = "";
}
{
    try { 
        t = <tCONSTCAD> {
            s = t.image;
        }
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba una cadena de texto");
    }

    {
        return s;
    }
}

void lista_escribibles() :
{
    RegistroExpr reg;
    String s;
}
{
    try { 
        (
            s = constcad() {
                for (int i=0; i<s.length(); i++) {
                    genCod.instruccion("STC " + (int) s.charAt(i));
                    genCod.instruccion("WRT 0");
                }
            }
          | reg = expresion(Clase_parametro.VAL) { // En stack está el resultado de la expresión
                if (reg.es_entero()) {
                    genCod.instruccion("WRT 1");
                }
                else if (reg.es_caracter()) {
                    genCod.instruccion("WRT 0");
                }
                else if (reg.es_booleano()) {
                    genCod.instruccion("WRT 1"); // TODO: Escribir Verdadero o Falso
                }
            }
        )
        (
          <tC>
          (
              s = constcad() {
                  for (int i=0; i<s.length(); i++) {
                      genCod.instruccion("STC " + (int) s.charAt(i));
                      genCod.instruccion("WRT 0");
                  }
              }
            | reg = expresion(Clase_parametro.VAL) { // En stack está el resultado de la expresión
                  if (reg.es_entero()) {
                      genCod.instruccion("WRT 1");
                  }
                  else if (reg.es_caracter()) {
                      genCod.instruccion("WRT 0");
                  }
                  else if (reg.es_booleano()) {
                      genCod.instruccion("WRT 1"); // TODO: Escribir Verdadero o Falso
                  }
              }
          )
        )*
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba una cadena o una expresión");
    }
}

void identificacion() :
{
    Token t = null, t2 = null;
    Simbolo s = null;
    Tipo_variable tipo = null;
    ArrayList<Simbolo> exp = new ArrayList<Simbolo>();
}
{
    try { 
        t = identificador() {
            if (t != null) {
                try { 
                    s = tabla_simbolos.buscar_simbolo(t.image);
                }
                catch (SimboloNoEncontradoException e) {
                    ErrorSemantico.error_semantico(e, t);
                    try { 
                        s = tabla_simbolos.introducir_variable(t.image, Tipo_variable.DESCONOCIDO, nivel, dir);
                        dir++; // Si la compilación es correcta no se utiliza
                    }
                    catch (SimboloYaExistenteException ignored) { } // Imposible
                }

                t2 = token;
            }
        }
        (
            tipo = asignacion() {
                if (t != null) { 
	                if (!(s.es_variable() || (s.es_parametro() && s.es_referencia()))) {
	                    ErrorSemantico.error_semantico(new SimboloNoAsignableException(), t);
	                }
	                else if (tipo != Tipo_variable.DESCONOCIDO && !s.es_desconocido() &&
	                           tipo != s.getVariable()) {
                        ErrorSemantico.error_semantico(new SimboloNoConcuerdaException(), t2);
	                }
                }
            }
          | invocacion_accion(s) {
                if (!s.es_desconocido() && !s.es_accion()) {
                    ErrorSemantico.error_semantico(new SimboloNoAccionException(), t);
                }
            }
        )
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba una asignación o una acción");
    }
}

Tipo_variable asignacion() :
{
    Tipo_variable tipo = null;
    RegistroExpr reg;
}
{
    try { 
        <tOPAS>
        reg = expresion(Clase_parametro.VAL) {
            tipo = reg.getVariable();
        }
        punto_y_coma()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba una asignación ':='");
    }

    {
        return tipo;
    }
}

void invocacion_accion(Simbolo s) :
{}
{
    try { 
        (
          argumentos(s)
        )?
        punto_y_coma()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void fmq() :
{}
{
    try { 
        <tFMQ>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba el fin del bloque MQ");
    }
}

void mientras_que() :
{
    Tipo_variable tipo = null;
    Token t = null;
    RegistroExpr reg;
    String etiqMQ, etiqFIN;
}
{
    try { 
        <tMQ> {
            t = token;

            // Generación de código
            genCod.escribir("; MQ");
            etiqMQ = genCod.nueva_etiqueta();
            genCod.escribir(etiqMQ + ":");
        }
        reg = expresion(Clase_parametro.VAL) {
            tipo = reg.getVariable();
            if (tipo != Tipo_variable.BOOLEANO) {
                ErrorSemantico.error_semantico(new SimboloNoConcuerdaException(), t);
            }

            // Generación de código
            etiqFIN = genCod.nueva_etiqueta();
            genCod.instruccion("JMF " + etiqFIN);
            genCod.escribir("; ENT");
        }
        lista_sentencias()
        fmq() {
            // Generación de código
            genCod.instruccion("JMP " + etiqMQ);
            genCod.escribir("; Fin MQ");
            genCod.escribir(etiqFIN + ":");
        }
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba un bloque MQ");
    }
}

void ent() :
{}
{
    try { 
        <tENT>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba 'ent'");
    }
}

void fsi() :
{}
{
    try { 
        <tFSI>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba el fin del bloque SI");
    }
}

void seleccion() :
{
    Tipo_variable tipo = null;
    Token t = null;
    RegistroExpr reg;
    String etiqSINO, etiqFIN;
}
{
    try { 
        <tSI> {
            t = token;
            genCod.escribir("; SI");
        }
        reg = expresion(Clase_parametro.VAL) {
            tipo = reg.getVariable();
            if (tipo != Tipo_variable.BOOLEANO) {
                ErrorSemantico.error_semantico(new SimboloNoConcuerdaException(), t);
            }

            // Generación de código
            etiqSINO = genCod.nueva_etiqueta();
            genCod.instruccion("JMF " + etiqSINO);
            genCod.escribir("; ENT");
        }
        ent()
        lista_sentencias() {
            // Generación de código
            etiqFIN = genCod.nueva_etiqueta();
            genCod.instruccion("JMP " + etiqFIN);
            genCod.escribir("; SI_NO");
            genCod.escribir(etiqSINO + ":");
        }
        (
          <tSI_NO>
          lista_sentencias()
        )?
        fsi() {
            // Generación de código
            genCod.escribir("; Fin SI");
            genCod.escribir(etiqFIN + ":");
        }
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba un bloque SI");
    }
}

void argumentos(Simbolo s) :
{}
{
    try { 
        ap()
        (
          lista_expresiones(s)
        )?
        cp()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void lista_expresiones(Simbolo simb) :
{
    LinkedList<Simbolo> parametros = null;
    Integer i = 0;
    Simbolo param = null;
    Clase_parametro clase = Clase_parametro.VAL;
    RegistroExpr exp;
    Token t = token;
    boolean exceso = false;

    if (!simb.es_desconocido() && simb.es_accion()) {
        parametros = simb.getLista_parametros();
        if (i < parametros.size()) {
            clase = parametros.get(i).getParametro();
        }
    }
}
{
    try { 
        exp = expresion(clase) {
            if (i < parametros.size()) {
                param = parametros.get(i);
                i++;
                if (i < parametros.size()) {
                    clase = parametros.get(i).getParametro();
                }
                    
                if (!exp.es_desconocido()) {
                    if (exp.getVariable() != param.getVariable()) {
                        ErrorSemantico.error_semantico(new SimboloNoConcuerdaException(), t);
                    }

                    if (param.es_referencia() && exp.es_valor()) {
                        ErrorSemantico.error_semantico(new SimboloNoAsignableException(), t.next);
                    }
                }
            }
            else {
                ErrorSemantico.error_semantico(new ExcesoParametrosException(), t.next);
                exceso = true;
            }
        }
        (
          <tC> {
              t = token;
          }
          exp = expresion(clase) {
              if (i < parametros.size()) {
                  param = parametros.get(i);
                  i++;
                  if (i < parametros.size()) {
                      clase = parametros.get(i).getParametro();
                  }
                    
                  if (!exp.es_desconocido()) {
                      if (exp.getVariable() != param.getVariable()) {
                          ErrorSemantico.error_semantico(new SimboloNoConcuerdaException(), t);
                      }

                      if (param.es_referencia() && exp.es_valor()) {
                          ErrorSemantico.error_semantico(new SimboloNoAsignableException(), t.next);
                      }
                  }
              }
              else {
                  if (!exceso) { 
                      ErrorSemantico.error_semantico(new ExcesoParametrosException(), t.next);
                  }
                  exceso = true;
              }
          }
        )*
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

RegistroExpr expresion(Clase_parametro clase) :
{
    TipoOperador op = null;
    Token t = null;
    RegistroExpr exp1 = new RegistroExpr(), exp2 = new RegistroExpr();
}
{
    try { 
        exp1 = expresion_simple(clase) {
            t = token;
        }
        (
          op = operador_relacional()
          exp2 = expresion_simple(clase) {
              if (exp1.getVariable() != exp2.getVariable() &&
                    !exp1.es_desconocido() && !exp2.es_desconocido()) {
                  ErrorSemantico.error_semantico(new SimboloNoConcuerdaException(), t);
              }
              else {
                  exp1 = new RegistroExpr(exp1, exp2, op);

                  // Generación de código
                  genCod.operacion(op);
              }
          }
        )?
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }

    {
        return exp1;
    }
}

TipoOperador operador_relacional() :
{
    TipoOperador tipo = null;
}
{
    try { 
          <tMAYOR> {
              tipo = TipoOperador.MAY;
          }
        | <tMENOR> {
              tipo = TipoOperador.MEN;
          }
        | <tIGUAL> {
              tipo = TipoOperador.IGU;
          }
        | <tMAI> {
              tipo = TipoOperador.MAI;
          }
        | <tMEI> {
              tipo = TipoOperador.MEI;
          }
        | <tNI> {
              tipo = TipoOperador.NI;
          }
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba un operador relacional");
    }

    {
        return tipo;
    }
}

RegistroExpr expresion_simple(Clase_parametro clase) :
{
    TipoOperador op = null;
    Token t = null;
    RegistroExpr exp1 = new RegistroExpr(), exp2 = new RegistroExpr();
}
{
    try { 
        exp1 = termino(clase) {
            t = token;
        }
        (
          op = operador_aditivo() {
              if (op == TipoOperador.OR && !exp1.es_booleano()) {
                  ErrorSemantico.error_semantico(new SimboloNoConcuerdaException(), t);
              }
              else if (op != TipoOperador.OR && !exp1.es_entero()) {
                  ErrorSemantico.error_semantico(new SimboloNoConcuerdaException(), t);
              }
              t = token;
          }
          exp2 = termino(clase) {
              if (exp1.getVariable() != exp2.getVariable() && !exp1.es_desconocido() &&
                    !exp2.es_desconocido()) {
                  ErrorSemantico.error_semantico(new SimboloNoConcuerdaException(), t);
              }
              else {
                  exp1 = new RegistroExpr(exp1, exp2, op);

                  // Generación de código
                  genCod.operacion(op);
              }
          }
        )*
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }

    {
        return exp1;
    }
}

TipoOperador operador_aditivo() :
{
    TipoOperador tipo = null;
}
{
    try { 
          <tSUMA> {
              tipo = TipoOperador.SUM;
          }
        | <tRESTA> {
              tipo = TipoOperador.RES;
          }
        | <tOR> {
              tipo = TipoOperador.OR;
          }
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba un operador aditivo");
    }

    {
        return tipo;
    }
}

RegistroExpr termino(Clase_parametro clase) :
{
    TipoOperador op = null;
    Token t = null;
    RegistroExpr exp1 = new RegistroExpr(), exp2 = new RegistroExpr();
}
{
    try { 
        exp1 = factor(clase) {
            t = token;
        }
        (
          op = operador_multiplicativo() {
              if (op == TipoOperador.AND && !exp1.es_booleano()) {
                  ErrorSemantico.error_semantico(new SimboloNoConcuerdaException(), t);
              }
              else if (op != TipoOperador.AND && !exp1.es_entero()) {
                  ErrorSemantico.error_semantico(new SimboloNoConcuerdaException(), t);
              }
              t = token;
          }
          exp2 = factor(clase) {
              if (exp1.getVariable() != exp2.getVariable() && !exp1.es_desconocido() &&
                    !exp2.es_desconocido()) {
                  ErrorSemantico.error_semantico(new SimboloNoConcuerdaException(), t);
              }
              else {
                  if ((op == TipoOperador.DIV || op == TipoOperador.MOD) &&
                        exp2.getValorEnt() != null && exp2.getValorEnt().equals(0)) {
                      ErrorSemantico.error_semantico(new DivisionPorCeroException(), t);
                  }
                  exp1 = new RegistroExpr(exp1, exp2, op);

                  // Generación de código
                  genCod.operacion(op);
              }
          }
        )*
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }

    {
        return exp1;
    }
}

TipoOperador operador_multiplicativo() :
{
    TipoOperador tipo = null;
}
{
    try { 
          <tMOD> {
              tipo = TipoOperador.MOD;
          }
        | <tDIV> {
              tipo = TipoOperador.DIV;
          }
        | <tMULTIPLICA> {
              tipo = TipoOperador.MUL;
          }
        | <tAND> {
              tipo = TipoOperador.AND;
          }
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba un operador multiplicativo");
    }

    {
        return tipo;
    }
}

RegistroExpr factor(Clase_parametro clase) :
{
    Token t = null;
    RegistroExpr exp = new RegistroExpr();
}
{
    try { 
          t = <tRESTA>
          exp = factor(clase) {
              if (!exp.es_entero() && !exp.es_desconocido()) {
                  ErrorSemantico.error_semantico(new SimboloNoConcuerdaException(), t);
              }
              else if (exp.getValorEnt() != null) {
                  exp = new RegistroExpr(exp);
                  exp.set_valor();
                  exp.setValorEnt(-1 * exp.getValorEnt());
              }

              // Generación de código
              genCod.instruccion("NGI");
          }
	    | t = <tNOT>
	      exp = factor(clase) {
              if (!exp.es_booleano() && !exp.es_desconocido()) {
                  ErrorSemantico.error_semantico(new SimboloNoConcuerdaException(), t);
              }
              else if (exp.getValorBool() != null) {
                  exp = new RegistroExpr(exp);
                  exp.set_valor();
                  exp.setValorBool(!exp.getValorBool());
              }

              // Generación de código
              genCod.instruccion("NGB");
          }
	    | ap()
	      exp = expresion(clase)
	      cp()
	    | <tENTACAR> // Entero a caracter
	      ap() {
              t = token;
          }
	      exp = expresion(clase) {
	          Character c = null;
	          
	          if (!exp.es_entero()) {
	              ErrorSemantico.error_semantico(new SimboloNoConcuerdaException(), t);
	          }
	          else if (exp.getValorEnt() != null) { 
	              if (exp.getValorEnt() < 0 || exp.getValorEnt() > 255) {
                      ErrorSemantico.error_semantico(new NumeroFueraRangoException(), t.next);
                  }
                  else {
                      c = (char) exp.getValorEnt().intValue();
                  }
	          }

              exp = new RegistroExpr();
              exp.set_valor();
              exp.set_caracter();
              if (c != null) {
                  exp.setValorChar(c);
              }
	      }
	      cp()
	    | <tCARAENT> // Caracter a entero
	      ap() {
              t = token;
          }
	      exp = expresion(clase) {
              Integer i = null;
              
              if (!exp.es_caracter()) {
                  ErrorSemantico.error_semantico(new SimboloNoConcuerdaException(), t);
              }
              else if (exp.getValorChar() != null) { 
                  i = (int) exp.getValorChar().charValue();
              }

              exp = new RegistroExpr();
              exp.set_valor();
              exp.set_entero();
              if (i != null) {
                  exp.setValorEnt(i);
              }
          }
	      cp()
	    | t = identificador() {
	          try { 
                  Simbolo aux = tabla_simbolos.buscar_simbolo(t.image);
                  exp = new RegistroExpr(aux);

                  if (!aux.es_desconocido()) {
                      // Generación de código
                      genCod.escribir("; Acceso a variable " + aux.getNombre());
                      genCod.instruccion("SRF 0 " + aux.strDir()); // Almacena en stack la @
                      if (clase == Clase_parametro.VAL) {
                          genCod.instruccion("DRF"); // Almacena en stack el valor
                      }
                  }
              }
              catch (SimboloNoEncontradoException e) {
                  ErrorSemantico.error_semantico(e, t);
                  try { 
                      Simbolo aux = tabla_simbolos.introducir_variable(t.image,
                            Tipo_variable.DESCONOCIDO, nivel, dir);
                      dir++; // Si la compilación es correcta no se utiliza
                      exp = new RegistroExpr(aux);
                  }
                  catch (SimboloYaExistenteException ignored) { } // Imposible
              }
	      }
	    | <tCONSTENTERA> {
	          exp = new RegistroExpr();
	          exp.set_entero();
              exp.set_valor();
              exp.setValorEnt(Integer.parseInt(token.image));

              // Generación de código
              genCod.instruccion("STC " + exp.getValorEnt());
	      }
	    | <tCONSTCHAR> {
              exp = new RegistroExpr();
              exp.set_caracter();
              exp.set_valor();
              exp.setValorChar(token.image.charAt(1));

              // Generación de código
              genCod.instruccion("STC " + (int) exp.getValorChar());
          }
	    | <tTRUE> {
              exp = new RegistroExpr();
              exp.set_booleano();
              exp.set_valor();
              exp.setValorBool(true);

              // Generación de código
              genCod.instruccion("STC 1");
          }
	    | <tFALSE> {
              exp = new RegistroExpr();
              exp.set_booleano();
              exp.set_valor();
              exp.setValorBool(false);

              // Generación de código
              genCod.instruccion("STC 0");
          }
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba un factor");
    }

    {
        return exp;
    }
}
