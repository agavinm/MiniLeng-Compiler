//*****************************************************************
// File:   MiniLengCompiler.jj
// Author: Andrés Gavín Murillo 716358
// Date:   4/5/2019
// Coms:   Procesadores de lenguajes - Compilador de MiniLengCompiler V3.0
//         JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
//*****************************************************************
options{    static = true;
    ignore_case = true;}PARSER_BEGIN(MiniLengCompiler)

package javacc;

import java.io.FileInputStream;
import lib.lexico.TablaVeces;
import lib.semantico.TablaSimbolos;
import lib.semantico.Simbolo;
import lib.semantico.Simbolo.Clase_parametro;
import lib.semantico.Simbolo.Tipo_variable;
import lib.semantico.SimboloNoEncontradoException;
import lib.semantico.SimboloYaExistenteException;
import java.util.ArrayList;

public class MiniLengCompiler {
    static boolean correcto = true;
    static boolean panic_mode = false;
    
    static TablaSimbolos tabla_simbolos = new TablaSimbolos();
    static Long dir = new Long(0);
    static int nivel = 0;
    static boolean tabla_simbolos_print = true;
    
    public static void main(String args []) throws ParseException {
        System.out.println("Compilador de MiniLengCompiler V3.0 Autor: Andrés Gavín Murillo 716358. Ayuda: ./compilador -h\n");
        
        Boolean verbose = false;
        MiniLengCompiler compiler;
        TablaVeces tabla = new TablaVeces();

        // Lanzar compilador
        if (args.length == 0) { // Sin argumentos
            System.out.println("Uso: ./compilador [argumentos] [archivo]");
            return ;
        }
        else { // Opción ayuda
            if (args[0].equals("-h")) {
                System.out.println("Uso: ./compilador [argumentos] [archivo]");
                System.out.println("     [] -> opcional");
                System.out.println("Argumentos:");
                System.out.println("    -h  -> Muestra la ayuda");
                System.out.println("    -p  -> Panic mode");
                System.out.println("    -v  -> Muestra información adicional");
                return ;
            }
            else {
                String file_name = null;
                
                for (int i=0; i<args.length; i++) {
                    if (args[i].equals("-p"))
                        panic_mode = true;
                    else if (args[i].equals("-v"))
                        verbose = true;
                    else
                        file_name = args[i];
                }

                if (file_name != null) { 
	               try {
	                   compiler = new MiniLengCompiler(new FileInputStream(file_name));
	               }
	               catch (java.io.FileNotFoundException e) {
	                   System.out.println("Fichero " + file_name + " no encontrado.");
	                   return ;
	               }
                }
	            else {
	               System.out.println("Fichero no encontrado.");
                   return ;
                }
            }

            try { 
                MiniLengCompiler.programa(verbose);
                if (correcto)
                    System.out.println("Compilación correcta.");
            }
            catch (TokenMgrError e) { // Error léxico
                System.out.println("ERROR LÉXICO (<" + SimpleCharStream.getBeginLine() + ", " + 
                    SimpleCharStream.getBeginColumn() + ">) : símbolo no reconocido: <" +
                    SimpleCharStream.GetImage().charAt(MiniLengCompilerTokenManager.curLexState) + ">");
                
                return ;
            }
        }
    }

    private static void panic(ParseException e, String msg, int kind) {
        Token lastRead = MiniLengCompiler.getNextToken();

        while (token.kind != kind && token.kind != EOF)
            token = MiniLengCompiler.getNextToken();

        String error_msg = "AVISO SINTÁCTICO (<" + lastRead.beginLine + ", " + 
            lastRead.beginColumn + ">) : <";
        if (kind != tFIN)
            error_msg += "Símbolo obtenido: '" + lastRead.image + "'. ";
        error_msg += msg + " (PANIC MODE)>";
        
        System.out.println(error_msg);
    }

    private static void error_sintactico(ParseException e, String msg) {
        correcto = false;
        Token lastRead = MiniLengCompiler.getNextToken();
        
        System.out.println("ERROR SINTÁCTICO (<" + lastRead.beginLine + ", " + 
            lastRead.beginColumn + ">) : <Símbolo obtenido: '" + lastRead.image +
            "'. " + msg + ">");
    }

    private static void error_sintactico(ParseException e) {
        error_sintactico(e, "");
    }

    private static void error_semantico(SimboloNoEncontradoException e, Token t) {
        correcto = false;
        
        System.out.println("ERROR SEMÁNTICO (<" + t.beginLine + ", " + 
            t.beginColumn + ">) : <No existe ningún símbolo con nombre '" +
            t.image + "'>");
    }
    
    private static void error_semantico(SimboloYaExistenteException e, Token t) {
        correcto = false;
        
        System.out.println("ERROR SEMÁNTICO (<" + t.beginLine + ", " + 
            t.beginColumn + ">) : <Ya existe un símbolo con nombre '" +
            t.image + "'>");
    }
}
// Análisis léxico
PARSER_END(MiniLengCompiler)SKIP :{  " "| "\r"| "\t"| "\n"
| "%" : COMENTARIO}

< COMENTARIO > SKIP :
{
  "\n" : DEFAULT
}

< COMENTARIO > MORE :
{
  < ~[] >
}

TOKEN : /* Estructuras */
{  < tPROGRAMA : "programa" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tPROGRAMA);
    }
| < tPRINCIPIO : "principio" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tPRINCIPIO);
    }
| < tFIN : "fin" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tFIN);
    }
| < tSI : "si" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tSI);
    }
| < tENT : "ent" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tENT);
    }
| < tSI_NO : "si_no" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tSI_NO);
    }
| < tFSI : "fsi" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tFSI);
    }
| < tMQ : "mq" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tMQ);
    }
| < tFMQ : "fmq" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tFMQ);
    }
| < tACCION : "accion" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tACCION);
    }
| < tPC : ";" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tPC);
    }
| < tC : "," >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tC);
    }
}

TOKEN : /* Tipos de datos */
{
  < tVAR : "var" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tVAR);
    }
| < tENTERO : "entero" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tENTERO);
    }
| < tBOOLEANO : "booleano" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tBOOLEANO);
    }
| < tCARACTER : "caracter" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tCARACTER);
    }
| < tVAL : "val" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tVAL);
    }
| < tREF : "ref" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tREF);
    }
}

TOKEN : /* Operadores lógicos */
{
  < tAND : "and" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tAND);
    }
| < tOR : "or" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tOR);
    }
| < tNOT : "not" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tNOT);
    }
| < tMAYOR : ">" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tMAYOR);
    }
| < tMENOR : "<" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tMENOR);
    }
| < tIGUAL : "=" >
    {
      TablaVeces.incrementarValor(TablaVeces.tipo_token.tIGUAL);
    }
| < tMAI : ">=" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tMAI);
    }
| < tMEI : "<=" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tMEI);
    }
| < tNI : "<>" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tNI);
    }
| < tTRUE : "true" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tTRUE);
    }
| < tFALSE : "false" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tFALSE);
    }
}

TOKEN : /* Operaciones */
{
  < tESCRIBIR : "escribir" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tESCRIBIR);
    }
| < tLEER : "leer" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tLEER);
    }
| < tENTACAR : "entacar" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tENTACAR);
    }
| < tCARAENT : "caraent" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tCARAENT);
    }
}
TOKEN : /* Operadores aritméticos */{
  < tMOD : "mod" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tMOD);
    }
| < tDIV : "div" | "/" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tDIV);
    }
| < tOPAS : ":=" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tOPAS);
    }
| < tSUMA : "+" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tSUMA);
    }
| < tRESTA : "-" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tRESTA);
    }
| < tMULTIPLICA : "*" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tMULTIPLICA);
    }
| < tAP : "(" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tAP);
    }
| < tCP : ")" >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tCP);
    }}TOKEN :{  < tCONSTENTERA : (< DIGITO >)+ >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tCONSTENTERA);
    }| < #DIGITO : [ "0"-"9" ] >
| < tCONSTCHAR : ["\""] ~["\""] ["\""] >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tCONSTCHAR);
    }
| < tCONSTCAD : ["\""] (~["\""])+ ["\""] >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tCONSTCAD);
    }
| < tIDENTIFICADOR : (< LETRA > | (< LETRA > | "_") (< LETRA > | < DIGITO > | "_")*
    (< LETRA > | < DIGITO >)) >
    {
        TablaVeces.incrementarValor(TablaVeces.tipo_token.tIDENTIFICADOR);
    }
| < #LETRA : [ "A"-"Z" ] >}

// Análisis sintáctico

void punto_y_coma() :
{}
{
    try { 
        <tPC>
    }
    catch (ParseException e) { // Error sintáctico
        if (panic_mode)
            panic(e, "Se esperaba ';'", tPC);
        else
            error_sintactico(e, "Se esperaba ';'");
    }
}

Token identificador() :
{
    Token t = null;
}
{
    try { 
        t = <tIDENTIFICADOR>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba un identificador");
    }
    
    {
        return t;
    }
}
void programa(Boolean verbose) :
{
    Token t = null;
}
{
    try { 
	    <tPROGRAMA>
	    t = identificador() {
	        tabla_simbolos.introducir_programa(t.image, dir);
	    }
	    punto_y_coma()
	    declaracion_variables()
	    declaracion_acciones()
	    bloque_sentencias()
	    ( <EOF> )?
	        {
	            if (correcto) {
                    tabla_simbolos.eliminar_variables(nivel);
                    tabla_simbolos.eliminar_acciones(nivel);
                    //tabla_simbolos.eliminar_parametros_ocultos(nivel+1); // TODO: Debería de ser como la anterior pero no va
                    tabla_simbolos.eliminar_programa();
                    
                    if (tabla_simbolos_print)
                        System.out.print(tabla_simbolos.print());
                    if (verbose)
                        TablaVeces.print();
                }
	            return;
	        }
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba la declaración del programa");
    }
}

void declaracion_variables() :
{}
{
    try { 
        (
          declaracion()
          punto_y_coma()
        )*
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void declaracion() :
{
    Token t = null;
    ArrayList<Token> ids;
    Tipo_variable tipo;
}
{
    try { 
        tipo = tipo_variables()
        ids = identificadores() {
            for (int i=0; i<ids.size(); i++) {
                t = ids.get(i);
                tabla_simbolos.introducir_variable(t.image, tipo, nivel, dir);
            }
        }
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
    catch (SimboloYaExistenteException e) { // Error semántico
        error_semantico(e, t);
    }
}

Tipo_variable tipo_variables() :
{
    Tipo_variable tipo = null;
}
{
    try { 
          <tENTERO> {
              tipo = Tipo_variable.ENTERO;
          }
        | <tCARACTER> {
              tipo = Tipo_variable.CHAR;
          }
        | <tBOOLEANO> {
              tipo = Tipo_variable.BOOLEANO;
          }
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba el tipo de varibale");
    }

    {
        return tipo;
    }
}

ArrayList<Token> identificadores() :
{
    ArrayList<Token> tokens = new ArrayList<Token>();
    Token t = null;
}
{
    try { 
        t = identificador() {
            tokens.add(t);
        }
        (
          <tC>
          t = identificador() {
              tokens.add(t);
          }
        )*
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }

    {
        return tokens;
    }
}

void declaracion_acciones() :
{}
{
    try { 
        (
          declaracion_accion()
        )*
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void declaracion_accion() :
{}
{
    try { 
        cabecera_accion()
        punto_y_coma()
        declaracion_variables()
        declaracion_acciones()
        bloque_sentencias() {
            tabla_simbolos.eliminar_variables(nivel);
            tabla_simbolos.eliminar_acciones(nivel);
            tabla_simbolos.ocultar_parametros(nivel);
            nivel--;
        }
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void cabecera_accion() :
{
    Token t = null;
}
{
    try { 
        <tACCION>
        t = identificador() {
            tabla_simbolos.introducir_accion(t.image, nivel, dir);
            nivel++;
        }
        parametros_formales()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba la declaración de una acción");
    }
    catch (SimboloYaExistenteException e) { // Error semántico
        error_semantico(e, t);
    }
}

void ap() :
{}
{
    try { 
        <tAP>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba '('");
    }
}

void cp() :
{}
{
    try { 
        <tCP>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba ')'");
    }
}

void parametros_formales() :
{}
{
    try { 
        (
          ap()
          (
            parametros()
          )*
          cp()
        )?
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void lista_parametros() :
{}
{
    try { 
        (
          punto_y_coma()
          parametros()
        )?
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void parametros() :
{
    Token t = null;
    ArrayList<Token> ids;
    Clase_parametro clase;
    Tipo_variable tipo;
}
{
    try { 
        clase = clase_parametros()
        tipo = tipo_variables()
        ids = identificadores() {
            for (int i=0; i<ids.size(); i++) {
                t = ids.get(i);
                tabla_simbolos.introducir_parametro(t.image, tipo, clase, nivel, dir);
            }
        }
        lista_parametros()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
    catch (SimboloYaExistenteException e) { // Error semántico
        error_semantico(e, t);
    }
}

Clase_parametro clase_parametros() :
{
    Clase_parametro clase = null;
}
{
    try { 
          <tVAL> {
              clase = Clase_parametro.VAL;
          }
        | <tREF> {
              clase = Clase_parametro.REF;
          }
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba la clase de parámetro");
    }

    {
        return clase;
    }
}

void principio() :
{}
{
    try { 
        <tPRINCIPIO>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba la declaración del principio del bloque");
    }
}

void bloque_sentencias() :
{}
{
    try { 
        principio()
        lista_sentencias()
        <tFIN> {
	        if (tabla_simbolos_print)
	            System.out.print(tabla_simbolos.print());
        }
    }
    catch (ParseException e) { // Error sintáctico
        if (panic_mode)
            panic(e, "Se esperaba la declaración del fin del bloque", tFIN);
        else
            error_sintactico(e, "Se esperaba la declaración del fin del bloque");
    }
}

void lista_sentencias() :
{}
{
    try { 
        (
          sentencia()
        )+
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void sentencia() :
{}
{
    try { 
          leer() punto_y_coma()
	    | escribir() punto_y_coma()
	    | identificacion()
	    | seleccion()
	    | mientras_que()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void leer() :
{}
{
    try { 
        <tLEER>
        ap()
        lista_asignables()
        cp()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void lista_asignables() :
{}
{
    try { 
        identificadores()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void escribir() :
{}
{
    try { 
        <tESCRIBIR>
        ap()
        lista_escribibles()
        cp()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void constcad() :
{}
{
    try { 
        <tCONSTCAD>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba una cadena de texto");
    }
}

void lista_escribibles() :
{}
{
    try { 
        (
            constcad()
          | expresion()
        )
        (
          <tC>
          (
              constcad()
            | expresion()
          )
        )*
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void identificacion() :
{
    Token t = null;
}
{
    try { 
        t = identificador()
        (
            asignacion()
          | invocacion_accion()
        )
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void asignacion() :
{}
{
    try { 
        <tOPAS>
        expresion()
        punto_y_coma()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba una asignación ':='");
    }
}

void invocacion_accion() :
{}
{
    try { 
        (
          argumentos()
        )?
        punto_y_coma()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void fmq() :
{}
{
    try { 
        <tFMQ>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba el fin del bloque MQ");
    }
}

void mientras_que() :
{}
{
    try { 
        <tMQ>
        expresion()
        lista_sentencias()
        fmq()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void ent() :
{}
{
    try { 
        <tENT>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba 'ent'");
    }
}

void fsi() :
{}
{
    try { 
        <tFSI>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba el fin del bloque SI");
    }
}

void seleccion() :
{}
{
    try { 
        <tSI>
        expresion()
        ent()
        lista_sentencias()
        (
          <tSI_NO>
          lista_sentencias()
        )?
        fsi()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void argumentos() :
{}
{
    try { 
        ap()
        (
          lista_expresiones()
        )?
        cp()
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void lista_expresiones() :
{}
{
    try { 
        expresion()
        (
          <tC>
          expresion()
        )*
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void expresion() :
{}
{
    try { 
        expresion_simple()
        (
          operador_relacional()
          expresion_simple()
        )?
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void operador_relacional() :
{}
{
    try { 
          <tMAYOR>
        | <tMENOR>
        | <tIGUAL>
        | <tMAI>
        | <tMEI>
        | <tNI>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba un operador relacional");
    }
}

void expresion_simple() :
{}
{
    try { 
        termino()
        (
          operador_aditivo()
          termino()
        )*
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void operador_aditivo() :
{}
{
    try { 
          <tSUMA>
        | <tRESTA>
        | <tOR>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba un operador aditivo");
    }
}

void termino() :
{}
{
    try { 
        factor()
        (
          operador_multiplicativo()
          factor()
        )*
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e);
    }
}

void operador_multiplicativo() :
{}
{
    try { 
          <tMOD>
        | <tDIV>
        | <tMULTIPLICA>
        | <tAND>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba un operador multiplicativo");
    }
}

void factor() :
{
    Token t = null;
}
{
    try { 
          <tRESTA> factor()
	    | <tNOT> factor()
	    | ap() expresion() cp()
	    | <tENTACAR> ap() expresion() cp()
	    | <tCARAENT> ap() expresion() cp()
	    | t = identificador()
	    | <tCONSTENTERA>
	    | <tCONSTCHAR>
	    | <tTRUE>
	    | <tFALSE>
    }
    catch (ParseException e) { // Error sintáctico
        error_sintactico(e, "Se esperaba un factor");
    }
}
